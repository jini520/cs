# HTTP 개요

HTTP는 html 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다. HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며, 클라이언트-서버 프로토콜이기도 하다. 클라이언트-서버 프로토콜이란 수신자 측에서 요청이 초기화되는 프로토콜을 의미한다.

클라이언트와 서버들은 개별적인 메세지 교환에 의해 통신한다.

HTTP는 애플리케이션 계층의 프로토콜로, 신뢰 가능한 전송 프로토콜이라면 이론상으로는 무엇이든 사용할 수 있으나 TCP 혹은 암호화된 TCP 연결인 TLS를 통해 전송된다. HTTP의 확장성 덕분에, 오늘날 하이퍼텍스트 문서 뿐만 아니라 이미지와 비디오 혹은 html 폼 결과와 같은 내용을 서버로 포스트하기 위해서도 사용된다. HTTP는 또한 필요할 때마다 웹 페이지를 갱신하기 위해 문서의 일부를 가져오는데 사용될 수도 있다.

## HTTP 기반 시스템의 구성요소

HTTP는 클라이언트-서버 프로토콜이다. 요청은 하나의 개체, 사용자 에이전트(대부분의 경우 브라우저)에 의해 전송된다.

각각의 개별적인 요청들은 서버로 보내지며, 서버는 요청을 처리하고 응답을 제공한다. 이 요청과 응답 사이에는 여러 개체들이 있는데, 다양한 작업을 수행하는 게이트웨이 또는 캐시 역할을 하는 프록시 등이 있다.

실제로는 브라우저와 요청을 처리하는 서버 사이에는 좀 더 많은 컴퓨터들이 존재한다(라우터, 모뎀 등). 웹의 계층적인 설계 덕분에, 이들은 네트워크와 전송 계층 내로 숨겨진다. HTTP는 애플리케이션 계층의 최상위에 있다.

### 클라이언트: 사용자 에이전트

사용자 에이전트는 사용자를 대신하여 동작하는 모든 도구이다. 이 역할은 주로 브라우저에 의해 수행된다.

브라우저는 항상 요청을 보내는 개체이다.

웹페이지를 표시하기 위해, 브라우저는 페이지의 html 문서를 가져오기 위한 요청을 전송한 뒤, 파일을 구문 분석하여 실행해야 할 스크립트 그리고 페이지 내 포함된 하위 리소스들을 잘 표시하기 위한 레이아웃 정보에 대응하는 추가적인 요청들을 가져온다. 그 뒤, 브라우저는 완전한 문서인 웹 페이지를 표시하기 위해 그런 리소스들을 혼합하낟. 브라우저에 의해 실행된 스크립트는 이후 단계를 좀 더 많은 리소스들을 가져올 수 있으며 브라우저는 그에 따라 웹 페이지를 갱신하게 된다.

### 웹 서버

통신 채널의 반대편에는 클라이언트에 의한 요청에 대한 문서를 제공하는 서버가 존재한다. 서버는 사실 상 논리적으로 단일 기계이다. 이는 로드 밸런싱 혹은 다른 컴퓨터들의 정보를 얻고 완전하게 혹은 부분적으로 문서를 생성하는 소프트웨어의 복잡한 부분을 공유하는 서버들의 집하일 수도 있기 때문이다.

### 프록시

웹 브라우저와 서버 사이에서는 수많은 컴퓨터와 머신이 HTTP 메세지를 이어 받고 전달한다. 여러 계층으로 이루어진 웹 스택 구조에서 이러하 컴퓨터/머신들은 대부분 전송, 네트워크 혹은 물리 계층에서 동작하며, 성능에 상당히 큰 영향을 주지만 HTTP 계층에서는 이들이 어떻게 동작하는지 눈에 보이지 않는다. 이러한 컴퓨터/머신 중에서도 애플리케이션 계층에서 동작하는 것들을 일반적으로 프록시라고 부른다. 프록시는 눈에 보이거나 그렇지 않을 수도 있으며 다양한 기능을 수행할 수 있다.

- 캐싱
- 필터링
- 로드 밸런싱
- 인증
- 로깅

## HTTP의 기초적인 측면

### HTTP는 간단하다

HTTP는 사람이 읽을 수 있으며 간단하게 고안되었다. HTTP/2가 다소 더 복잡해졌지만 여전히 HTTP 메세지를 프레임별로 캡슐화하여 간결함을 유지하였다. HTTP메세지들은 사람이 읽고 이해할 수 있어, 테스트하기 쉽다.

### HTTP는 확장 가능하다

HTTP/1.0에서 소개된 HTTP 헤더는 HTTP를 확장하고 실험하기 쉽게 만들어주었다. 클라이언트와 서버가 새로운 헤더의 시맨틱에 대해 간단한 합의만 한다면, 언제든지 새로운 기능을 추가할 수 있다.

### HTTP는 상태는 없지만 세션은 있다

HTTP는 상태를 저장하지 않는 무상태 프로토콜이다. 동일한 연결 상에서 연속하여 전달된 두 개의 요청 사이에는 연결고리가 없다. HTTP의 핵심은 상태가 없는 것이지만 HTTP 쿠키는 상태가 있는 세션을 만들도록 해준다. 헤더 확장성을 사용하여, 동일한 컨텍스트 또는 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가된다.

### HTTP와 연결

연결은 전송 계층에서 제어되므로 근본적으로 HTTP 영역 밖이다. HTTP는 연결될 수 있도록 하는 근본적인 전송 프로토콜을 요구하지 않는다. HTTP는 연결이 필수는 아니지만 연결 기반인 TCP 표준에 의존한다.

클라이언트와 서버가 HTTP를 요청/응답으로 교환하기 전에 여러 왕복이 필요한 프로세스인 TCP 연결을 설정해야한다. HTTP/1.0의 기본 동작은 각 요청/응답에 대해 별도의 TCP 연결을 여는 것이다. 이 동작은 여러 요청을 연속해서 보내는 경우에는 단일 TCP 연결을 공유하는 것보다 효율적이지 못하다.

이러한 결함을 개선하기 위해, HTTP/1.1은 파이프라이닝 개념과 지속적인 연결 개념을 도입했다. 기본적인 TCP 연결은 `Connection` 헤더를 사용해 부분적으로 제어할 수 있다. HTTP/2는 연결을 좀 더 지속되고 효율적으로 유지하는데 도움이 되도록, 단일 연결 상에서 메세지를 다중 전송한다.

HTTP에 더 알맞은 좀 더 나은 전송 프로토콜을 설계하는 실험이 진행중이다. 예를 들어 구글은 좀 더 신뢰성있고 효율적인 전송 프로토콜을 제공하기 위해 UDP기반의 QUIC를 실험하고 있다.

[QUIC](https://en.wikipedia.org/wiki/QUIC)

## HTTP로 제어할 수 있는 것

HTTP는 웸의 더 많은 기능들을 제어하도록 허용되어 왔다.

- 캐시
  - HTTP로 문서가 캐시되는 방식을 제어할 수 있다.
  - `Cache-Control: public, max-age=3600` 와 같은 헤더를 통해 서버는 캐시 대상과 기간을 프록시와 클라이언트에 지시할 수 있다.
  - `Cache-Control: no-chche` 와 같은 헤더를 통해 반대로 클라이언트는 저장된 문서를 무시하고 원본 서버에서 받아오라고 지시할 수 있다.
  - `Cache-Control: no-store` 처럼 캐시 자체를 하지 말라고 지시할 수도 있다.
- `origin` 제약사항을 완화
  - `Same-Origin Policy` : 스누핑과 다른 프라이버스 침해를 막기 위해 브라우저는 보안상, 다른 출처의 웹사이트 간 데이터 접근을 엄격히 제한한다. 같은 프로토콜 + 도메인 + 포트여야만 데이터 접근 허용
  - `Same-Origin Policy` 와 같은 제약 사항은 서버에 부담이 되지만 HTTP 헤더를 통해서 완화시킬 수 있다.
  - `CORS` : 서버가 `Access-Control-Allow-Origin: HTTP:// example.com` 과 같은 HTTP 응답 헤더를 보내면 다른 origin에서도 접근이 가능하게 된다.
  - `CORS` 덕분에 문서는 다른 도메인으로부터 전달된 정보를 패치워크할 수 있다.
- 인증
  - 어떤 페이지들은 보호되어 오로지 특정 사용자만이 접근할 수 있다. 기본 인증은 HTTP를 통해 `www-Authenticate` 또는 유사한 헤더를 사용해 제공되거나, HTTP 쿠키를 사용해 특정 세션을 설정하여 이루어질 수도 있다.
- 프록시와 터널링
  - `인트라넷` : 회사 내부에서만 접근 가능한 내부 네트워크
  - 실제 IP/위치를 숨긴 채, 프록시를 통해 간접적으로 통신한다.
  - HTTP 요청은 네트워크 장벽을 가로지르기 위해 프록시를 통해 나가게 된다.
  - `네트워크 장벽` : 방화벽, NAT, 보안 게이트웨이 등
  - `Proxy` : 외부와 내부를 모두 볼 수 있는 중간 서버
  - 클라이언트는 프록시에게 요청을 보내고, 프록시는 이 요청을 외부로 전달. 외부 서버는 응답을 프록시에 보내고, 프록시는 응답을 내부 클라이언트에게 전달 하는 형태로 진행된다.
  - `CONNECT www.example.com:443 HTTP/1.1`
  - HTTP는 기본적으로 텍스트 기반이기 때문에, 보안이 필요한 HTTPs를 프록시가 읽지 못하기 때문에 `터널링` 을 통해 외부 서버로 암호화된 데이터를 외부로 전달한다.
- 세션
  - 쿠키 사용은 서버 상태를 요청과 연결하도록 해준다. HTTP가 기본적으로 무상태 프로토콜임에도 세션을 만들어주는 계기가 된다. 사용자 구성을 허용하는 모든 사이트에 대해서 유용하다.

## HTTP 흐름

클라이언트가 서버와 통신하고자 할 때, 최종 서버가 됐든 중간 프록시가 됐든 다음 단계의 과정을 수행한다.

1. TCP 연결을 연다. TCP 연결은 요청을 보내거나 응답을 받는데 사용된다. 클라이언트는 새 연결을 열거나, 기존 연결을 재사용하거나, 서버에 대한 여러 TCP 연결을 열 수 있다.
2. HTTP 메세지를 전송한다.
3. 서버에 의해 전송된 응답을 읽는다.
4. 연결을 닫거나 다른 요청들을 위해 재사용한다.

## HTTP 메세지

HTTP/1.1과 초기 HTTP 메세지는 사람이 읽을 수 있다. HTTP/2에서 이 메세지들은 새로운 이진 구조인 프레임 안으로 임베드되어, 헤어의 압축과 다중화 같은 최적화를 가능케 한다. 본래의 HTTP 메세지의 일부분만이 이 버전의 HTTP 내에서 전송된다고 할지라도, 각 메세지의 의미들은 변하지 않으며 클라이언트는 본래의 HTTP/1.1 요청을 재구성한다. 그러므로 HTTP/1.1 포맷 내에서 HTTP/2를 이해하는 것은 여전히 유용하다.

### 요청

```
GET       /       HTTP/1.1
[Method]  [path]  [Protocol version]

Host: developer.mozilla.org
Accept-Language: kr
[Headers]
```

### 응답

```
HTTP/1.1            200             OK
[Protocol version]  [Status code]   [Status message]

date: Tue, 18 Jun 2024 10:03:55 GMT
cache-control: public, max-age=3600
content-type: text/html
[Headers]
```
