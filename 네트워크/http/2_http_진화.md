# HTTP 진화

## HTTP/0.9 (원-라인 프로토콜)

HTTP 초기 버전에는 버전 번호가 없었다. HTTP/0.9는 극히 단순하다. 요청은 단일 라인으로 구성되며 리소스에 대한 경로로 가능한 메서는 `GET` 이 유일했다. 서버에 연결되면 프로토콜, 서버, 포트가 필요하지 않으므로 전체 URL은 포함되지 않았다.

### 요청

```
GET /mypage.html
```

### 응답

```html
<html>
  A very simple HTML page
</html>
```

HTTP 헤더가 없었는데 이는 HTML 파일만 전송될 수 있으며 다른 유형의 문서는 전송될 수 없음을 의미한다. 상태 혹은 오류 코드도 없었다. 문제가 발생한 경우, 특정 HTML 파일이 만들어지고 사람이 처리할 수 있도록, 해당 파일 내부에 문제에 대한 설명이 HTML 파일에 추가되었다.

## HTTP/1.0

HTTP/0.9는 매우 제한적이었으며, 브라우저와 서버를 통해서 빠르게 다양한 특징을 가지게 되었다.

- 각 요청 안에 버전 정보가 포함되어 전송되었다.
- 상태 코드 라인 또한 응답의 시작 부분의 붙어 전송되었다. 브라우저가 요청에 대한 성공과 실패를 알 수 있고, 그 결과에 대한 동작을 할 수 있게 되었다.
- HTTP 헤더 개념은 요청과 응답 둘 다 도입되어, 메타데이터 전송이 가능해졌고, 프로토콜이 극도로 유연하고 확장성이 높아졌다.
- `Content-type` 덕분에, 일반 HTML 파일들 외에 다른 문서들을 전송할 수 있었다.

## HTTP/1.1 (표준 프로토콜)

- 연결을 재사용할 수 있어 시간이 절야된다. 단일 원본 문서 내로 포함된 리소스들을 표시하기 위해 더 이상 여러 번 연결을 열 필요가 없기 때문이다.
- 파이프라이닝을 추가하여, 첫번째 요청에 대한 응답이 완전히 전송되기 전에 두번째 요청 전송을 가능케 하여, 통신 지연 시간이 단축되었다.
- 청크된 응답도 지원되었다.
- 추가적인 캐시 제어 메커니즘이 도입되었다.
- 언어, 인코딩 혹은 타입을 포함한 컨텐츠 협상이 도입되어, 클라이언트와 서버로 하여금 교환하려는 가장 적합한 컨텐츠에 대한 합의를 할 수 있다.
- `Host` 헤더 덕분에, 동일한 IP 주소에 다른 도메인을 호스트하는 기능인 서버 배치가 가능해졌다.

### 보안 전송을 위한 HTTP 사용

기본 TCP/IP 스택을 통해 HTTP를 전송하는 대신에, TCP/IP 스택 위에 추가적인 암호화 전송 계층인 SSL을 만들어냈다. 서버와 클라이언트 간에 교환되는 메세지의 신뢰성을 암호화하고 보장했다. SSL은 표준화되어 TLS가 되었다.

### 복잡한 애플리케이션을 위한 HTTP 사용

2000년에 HTTP 사용에 대한 새로운 패턴인 representational state transfer([REST](https://www.notion.so/REST-22deaca91d93803986a5c2af928c4ce2?pvs=21))가 설계 되었다. API는 기본 HTTP/1.1 메서드를 사용하여 특정 URI에 대한 접근에 의존했다. 이를 통해 모든 웹 애플리케이션에서 API가 브라우저나 서버를 업데이트하지 않고도 데이터를 검색하고 수정할 수 있게 되었다. REST 모델의 단점은 각 웹 사이트가 자체 비표준 RESTful API를 정의하고 이를 완전히 제어할 수 있다는 것이다. 이는 클라이언트와 서버가 상호 운영가능한 \*DAV 확장과 차이가 있다.

### 웹의 보안 모델 완화

HTTP는 동일 출처 정책(Same Origin Policy)으로 알려진 웹 보안 모델과는 독립되어 있다. 현재의 웹 보안 모델은 HTTP가 만들어진 이후에 개발되었다. 서버는 새로운 HTTP 헤더 세트를 사용하여 이러한 제한을 언제, 얼마나 해제해야 하는지 클라이언트에 전송했다. 교차 출처 리소스 공유(CORS), 컨텐츠 보안 정책(CSP)과 같은 명세 안에 정의되었다.

## HTTP/2

웹 페이지가 복잡해지면서 더 많은 시각적 미디어가 표시되고 상호작용을 위한 스크립트 코드의 양과 크기가 증가하였다. 훨씬 더 많은 HTTP 요청을 통해, 많은 데이터가 전송되고, 이를 통해 HTTP/1.1 연결에 복잡성과 오버헤드가 많이 발생하였다. Google은 2010년 초반에 SPDY 프로토콜을 구현하였다. SPDY는 응답성 증가를 정의하고 중복 데이터 전송 문제를 해결하여 HTTP/2 프로토콜의 기반이 되었다.

### HTTP/2 프로토콜의 특징

- 텍스트 프로토콜이 아닌 이진 프로토콜이다. 읽을 수도 없고 수동으로 만들 수 없다.
- 다중화 프로토콜이다. 동일한 연결을 통해 병렬 요청을 수행할 수 있어, HTTP/1.x 프로토콜의 제약을 없애준다.
- 헤더를 압축한다. 요청 집합 간에 유사한 경우가 많으므로, 전송된 데이터의 중복과 오버헤드가 제거된다.
- 서버가 서버 푸시라는 메커니즘으로 클라이언트 캐시에 데이터를 저장할 수 있다.

## HTTP/3

HTTP/3에서는 이전 버전의 HTTP와 동일한 의미를 가지지만 전송 계층에서 TCP 대신 QUIC를 사용한다.

QUIC는 HTTP 연결에 대해서 훨씬 낮은 대기 시간을 제공하도록 설계되었다. HTTP/2와 마찬가지로 다중화 프로토콜이지만, HTTP/2는 단일 TCP 연결을 통해 실행되어 TCP 계층에서 처리되는 패킷 손실 감지 및 재전송이 모든 스트림을 차단할 수 있다. QUIC은 UDP를 통해 여러 스트림을 실행하고 각 스트림에 대하 독립적인 패킷 손실 감지 및 재전송을 구현하므로 오류가 발생하면 해당 패킷에 데이터가 있는 스트림만 차단된다.
